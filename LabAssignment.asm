; -------------------------------------------------------------------------------------	;
;	Лабораторная работа №n по курсу Программирование на языке ассемблера				;
;	Вариант №2.6																		;
;	Выполнил студент Балашов Илья.														;
;																						;
;	Исходный модуль LabAssignment.asm													;
;	Содержит функцию на языке ассемблера, разработанную в соответствии с заданием		;
; -------------------------------------------------------------------------------------	;
;	Задание: 
;		Реализовать фильтр Собеля обработки изображений с использованием вещественных
;       вычислений
.DATA
	TopBorder		qword	255
	BottomBorder	qword	0
	MultiplierTwo	dword	2	; Множитель "2" для фильтра Собеля
.CODE
; -------------------------------------------------------------------------------------	;
; Осуществляет фильтрацию одной цветовой составляющей изображения						;
; void Kernel( PBYTE pDst, PBYTE pSrc, int Width )										;
; Параметры:																			;
;	pDst   - адрес пиксела - результата обработки										;
;   pSrc   - адрес пиксела исходного изображения										;
;	Width  - ширина изображения в пикселах (количество столбцов)						;
; Внимание!!! Для корректной работы приложения необходимо определить константы в файле	;
;	Tuning.h в соответствии с заданием													;
; -------------------------------------------------------------------------------------	;
Kernel PROC	; [RCX] - pDst
			; [RDX] - pSrc
			; R8    - Width

	; Фильтр Собеля:
	; Обрабатываемая матрица имеет вид ([RDX] = z0):
	; (z1, z2, z3)
	; (z4, z5, z6)
	; (z7, z8, z9)
	; Пусть:
	; Gx = 2*(z4 - z0) + z1 + z7 - z3 - z9
	; Gy = 2*(z2 - z8) + z2 + z3 - z7 - z9
	; Тогда итоговое значение после обработки будет равно [RCX] = sqrt(Gx^2 + Gy^2)

	finit

	; Сохраняем изначальную вершину стека для последующего его восстановления
	mov r9, rsp

	; Выполняем чтение обрабатываемой матрицы в стек
	movzx rax, byte ptr [rdx]
	push rax
	movzx rax, byte ptr [rdx + 1]
	push rax
	movzx rax, byte ptr [rdx + 2]
	push rax
	movzx rax, byte ptr [rdx + r8]
	push rax
	movzx rax, byte ptr [rdx + r8 + 2]
	push rax
	movzx rax, byte ptr [rdx + 2*r8]
	push rax
	movzx rax, byte ptr [rdx + 2*r8 + 1]
	push rax
	movzx rax, byte ptr [rdx + 2*r8 + 2]
	push rax
	
	; Вычисляем Gx

	; Добавляем элементы с коэффициентом +-1
	fldz ; Инициализиуем сумму нулём
	fiadd dword ptr [rsp + 8* 7]
	fisub dword ptr [rsp + 8* 5]
	fiadd dword ptr [rsp + 8* 2]
	fisub dword ptr [rsp + 8* 0]

	; Добавляем элементы с коэффициентов +-2
	fldz ; Инициализиуем сумму нулём
	fiadd dword ptr [rsp + 8* 4]
	fisub dword ptr [rsp + 8* 3]
	fimul MultiplierTwo 
	faddp

	; Возводим Gx в квадртат
	fmul st(0),st(0)
	

	; Вычисляем Gy

	; Добавляем элементы с коэффициентом +-1
	fldz ; Инициализиуем сумму нулём
	fiadd dword ptr [rsp + 8* 7]
	fiadd dword ptr [rsp + 8* 5]
	fisub dword ptr [rsp + 8* 2]
	fisub dword ptr [rsp + 8* 0]

	; Добавляем элементы с коэффициентов +-2
	fldz
	fiadd dword ptr [rsp + 8* 6]
	fisub dword ptr [rsp + 8* 1]
	fimul MultiplierTwo ; Умножаем на 2
	faddp ; Добавляем элементы с коэффициентом 2 к сумме остальных элементов

	; Возводим Gy в квадртат
	fmul st(0),st(0)

	; Gx^2 + Gy^2
	faddp

	; sqrt(Gx^2 + Gy^2)
	fsqrt

	; Арифметика насыщения:
	; 1) Проверка верхней границы
	fild TopBorder			; Загрузили в FPU верхнюю границу (255)
	fcomi st(0),st(1)		; Если полученное новое значение пиксела больше 255,
	fcmovnbe st(0),st(1)	; то делаем его 255
	; 2) Проверка нижней границы
	fild BottomBorder		; Загрузили в FPU нижнюю границу (0)
	fcomi st(0),st(1)		; Если полученное новое значение пиксела меньше 0,
	fcmovb st(0),st(1)		; то делаем его нулём

	; Записываем вычисленное значение в матрицу
	sub rsp, 8				; Отодвигаем вершину стека, чтобы положитьв нее новое значение
	fistp qword ptr [rsp]	; Кладем вершину стека FPU на вершину стека
	pop rax					; Загружаем результат обработки в регистр общего назначение
	mov byte ptr [rcx], al	; Записываем результат

	; Очищаем стек
	mov rsp, r9

	; Возврат из функции
	ret
Kernel ENDP
END
